# List <arraylist, linkedlist>

### **ArrayList**

- 중복을 허용하고 순서를 유지하며 인덱스로 원소들을 관리한다는 점에서 배열과 상당히 유사
- 배열의 크기가 지정되면 고정되지만 ArrayList는 **클래스**이기 때문에 배열을 **추가 / 삭제**할 수 있는 메소드들이 존재

하지만 추가했을 때 배열이 동적으로 늘어나는 것이 아니라 용량이 꽉 찼을 경우 더 큰 용량의 배열을 만들어 옮기는 작업을 하게 됨

<그림 1>

![ArrayList](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fqp1KU%2FbtqEiLKhVVi%2Fh1IfW46J1Ks7nu1DBvgUmk%2Fimg.png)

ArrayList는 위와 같이 3개의 생성자가 존재

- 아무것도 매개변수로 받지 않는 생성자
- 초기 용량을 매개변수로 받는 생성자
- Collection 타입을 매개변수로 받는 생성자



여기서 첫번째, 두번째 생성자에 대해서 알아보겠습니다

```java
List<Integer> list = new ArrayList<>();
```

보통 ArrayList의 객체를 만들 때 위와 같이 만들게 됨. 위와 같이 만들면 아래와 같은 매개변수가 존재하지 않는 생성자가 만들어짐



```java
private static final int DEFAULT_CAPACITY = 10;

public ArrayList() {
	this.elementData = 	DEFAULTCPACITY_EMPTY_ELEMENTDATA;
}
```

위의 생성자를 이용해서 ArrayList를 만들게 되면  DEFAULT_CAPACITY = 10으로 정의됨.

한마디로 **배열의 크기 = 10** 으로 지정



##### **[질문 1] ArrayList 객체를 만들 때 초기 용량을 설정하는 것이 좋다**

- 많은 원소가 추가, 삭제가 되는 상황이라면 빈번하게 배열의 복사가 일어날 것
- 물론 초기 용량을 미리 예상하기는 쉽지 않지만 대략적으로 초기 용량을 생각하고, 그 예상하는 것보다는 살짝 더 여유있는 값으로 초기 용량을 설정해주는 것이 좋음

##### **[질문 2] add()을 통해서 ArrayList 용량이 꽉 찬다면**

```java
int newCapacity = oldCapacity + (oldCapacity >> 1);
```

- 용량을 늘리는 코드는 위와 같은 코드

- 해석해보면 **oldCapacity + oldCapacity / 2** 로 늘리고 있음

- oldCapacity가 8이라면 8 + 4 = 12



**ArraylList API 특징**

- add(E element) : 원소를 마지막에 추가하기
  - 배열에 마지막에 원소를 추가하는 것이기 때문에 빠르게 추가 할 수 있음
- add(int index, E element) : 원소를 지정된 위치에 추가하기
  - 배열에 마지막이 아닌 처음, 중간에 데이터를 넣어야 한다면 어떻게 될까
  - ex) 5번 인덱스까지 들어있는 배열에서 2번 인덱스에 원소를 추가한 상황이라면 2번 인덱스부터 원소들을 뒤로 한칸씩 미뤄서 중간에 공간을 만드는 작업이 필요하고 이 과정에서 시간이 많이 걸리게 됨
- remove(int index) : 원소의 인덱스로 삭제하기
  - 마지막 원소를 삭제한다면 쉽게 삭제할 수 있지만 중간이나 처음의 원소를 삭제하게 되면 빈공간을 다시 채워야하는 과정이 필요하기 때문에 **비효율적**임
- get(int index) : 인덱스에 해당하는 원소 찾아오기
  - 배열은 인덱스에 해당하는 원소를 O(1)에 찾아올 수 있기 때문에 탐색에는 매우 유리

간단하게 정리하면 ArrayList는 탐색을 빠르게 할 수 있지만, 중간에서 **추가**, **삭제**가 빈번하게 일어나면서 **비효율적**인 특징을 가지고 있음



### **LinkedList**

- LinkedList는 내부적으로 양방향의 연결 리스트로 구성되어 있어서 참조하려는 원소에 따라 처음부터 순방향으로 또는 역순으로 순화할 수 있음 (배열의 단점을 보완하기 위해서 LinkedList라는 자료구조가 고안됨)

![LinkedList](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/1335/2949.png)

**배열의 단점**

- 크기를 변경할 수 없음
  - 크기를 변경할 수 없으므로 새로운 배열을 생성해서 복사해야 함
  - 실행속도를 향상시키기 위해서는 충분히 큰 용량을 미리 정해놔야 하는데 이것이 메모리 낭비가 될 수 있음
- 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸림
  - 차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠름
  - 배열의 중간에 데이터를 추가하거나, 삭제하면 빈공간을 만들기 위해 데이터 이동이 필요하고, 빈 공간을 채우기 위해 데이터 이동이 빈번



**LinkedList API의 특징**

- add(E element) : 원소를 마지막에 추가하기
  - LinkedList도 마찬가지로 add 메소드가 존재
  - LinkedList는 배열처럼 인덱스를 가지고 있지 않음
  - 원소를 추가하기 위해서는 헤더에서부터 마지막까지 찾아가야 하기 때문에 시간이 많이 걸림
- add(int index, E element) : 원소를 지정된 위치에 추가하기
  - 인덱스를 지정해서 추가하는 것도 마찬가지로 해당 위치로 가려면 헤더부터 탐색해서 가야하기 때문에 시간이 걸리게 됨
- remove(int index) : 원소를 삭제하기
  - 원소를 삭제하려면 배열의 경우는 삭제하면 빈 공간을 다시 채워주는 작업이 필요하지만, LinkedList는 삭제하려는 원소 앞 or 뒤로 가서 가르키는 값을 null로 바꿔주면 됨
- get(int index) : 인덱스에 해당하는 원소 찾아오기
  - LinkedList는 ArrayList와 다르게 인덱스를 통해서 검색을 하는 것이 아니라 Head에서 부터 해당원소까지 검색해야 하기 때문에 O(n)에 찾을 수 있음



**ArrayList vs LinkedList**

- 순차적으로 추가 / 삭제하는 경우에는 ArrayList 가 LinkedList 빠름
  - 단순히 저장하는 시간만을 비교할수록 하기 위해서 ArrayList에서 배열 재배치가 일어나는 상황은 제외함
  - 순차적으로 삭제한다는 것은 마지막 데이터부터 삭제할 경우 각 요소들의 재배치가 필요하지 않기 때문에 상당히 빠름
- 중간 데이터를 **추가 / 삭제**하는 경우에는 LinkedList가 ArrayList보다 빠름
  - 중간 요소를 추가 또는 삭제하는 겨우, LinkedList는 각 요소간의 연결만 변경해주면 되기 때문에 처리 속도가 상당히 빠름
  - ArrayList는 각 요소들을 재배치하여 추가할 공간을 확보하거나 빈 공간을 채워야하기 때문에 처리 속도가 느림

| 컬렉션     | 읽기 (접근시간) | 추가 / 삭제 | 비 고                                                        |
| ---------- | --------------- | ----------- | ------------------------------------------------------------ |
| ArrayList  | 빠르다          | 느리다      | 순차적인 추가삭제는 더                                           빠름비효율적인 메모리 사용 |
| LinkedList | 느리다          | 빠르다      | 데이터가 많을 수록 접근성이 떨어짐                           |

> 다르고자 하는 데이터의 개수가 변하지 않는 경우라면, ArrayList가 최상의 선택이겠지만, 데이터 개수의 변경이 잦다면 LinkedList를 사용하는 것이 더 나은 선택이 될 것